### remove hospitalized confirmed and suspected cases since these are already summarized
ca_hospital_df <- removeCols(ca_hospital_df,c("hospitalized_covid_confirmed_patients","hospitalized_suspected_covid_patients"))
### rename date column to date
names <- colnames(ca_hospital_df)
names[2] <- "date"
colnames(ca_hospital_df) <- names
head(ca_hospital_df)
####Calculations - leave these in and strip out later since we are building from these values
#### Let's strip out capacity since it is generating negative values.
#### I suspect the available bed value and icu available, are not good values to use, since they don't represent staffing
#### and include beds that are incompatible for COVID patients including NICU and PICU specialized units.
#### Notably, there are anecdotal news reports saying hospitals are at capacity, yet this is not found in the data
#### We'll haveto go after impact differently
icu_capacity <- ca_hospital_df$icu_available_beds - ca_hospital_df$icu_combined
hospital_capacity <- ca_hospital_df$all_hospital_beds - ca_hospital_df$hospitalized_covid_patients
return(ca_hospital_df)
}#//*** END process_CA_hospital_data
#### Statewide Preview Model
correlation_model_statewide_by_summed_county <- function(input_df,input_test_field, input_predict_field){
### Build a statewide model of an attribute by modeling each County and summing the results.
### This is a relatively quick model, good for preliminary investigation.
### The Best model is a 15 day model using linear models. Correlation fails below 30. But it is fast.
###
county_names <- sort(unique(input_df$county))
#### Loop through each county Name and Build an offset
for (countyCounter in 1:length(county_names)) {
### init small counties, here so we dont accidentally overlook with incremental step throughs
if (countyCounter == 1){
too_small_to_calc_counties <- c()
}
### Get County Name for Loop
loop_county_name <- county_names[countyCounter]
print(paste0("BEGIN:",loop_county_name))
### get data frame with just the County data
loop_county_df <- input_df[which(input_df$county==loop_county_name),]
#print(tail(loop_county_df))
### Build offset columns for confirmed cases
loop_county_offset_df <- build_offset_columns(loop_county_df,input_test_field,2:30)
#print(tail(loop_county_offset_df))
### Build predictions for County: deaths ~ confirmed
loop_county_cor_df <- build_rolling_cor_offset(loop_county_offset_df,input_predict_field,30)
#print(tail(loop_county_cor_df))
### IF the sum(mse) is less than 2, Ignore those counties and append to the too small to calc list
if (sum(loop_county_cor_df$mse) < 2) {
too_small_to_calc_counties <- append(too_small_to_calc_counties,loop_county_name)
next
}
#print(tail(loop_county_cor_df))
print(paste0("Sum MSE: ",sum(loop_county_cor_df$mse)))
####################################
#### Build summed data frame
####################################
#### First time through initialize the data frame
if (countyCounter == 1) {
output_df <- data.frame(
date=loop_county_cor_df$date,
confirm_mse=loop_county_cor_df$mse,
confirm_deaths=loop_county_cor_df$predicted_deaths
)
next
}#//*** END initialize data frame
### Add in County data to cor_model_statewide_by_county_30_df
print(loop_county_name)
### Sum the county data and update the statewide output_df
for (updateCounter in 1:nrow(loop_county_cor_df)){
loop_master_row <- output_df[updateCounter,]
loop_county_cor_row <- loop_county_cor_df[updateCounter,]
#print(sum(loop_county_cor_row$mse))
#print(sum(loop_county_cor_row$predicted_deaths))
#### Sum Confirmed MSE
loop_master_row$confirm_mse <- sum(loop_master_row$confirm_mse + loop_county_cor_row$mse)
#### Sum Confirmed predicted deaths
loop_master_row$confirm_deaths <- sum(loop_master_row$confirm_deaths + loop_county_cor_row$predicted_deaths)
output_df[updateCounter,] <- loop_master_row
#print(loop_master_row)
}#//*** END Update State Model
#print(tail(output_df))
}###END each county same
return(output_df)
}#// END Build a state wide model by summed County using 30 correlation Model
####################################################
#### Expensive County Modeling
#### Models each County and writes to a file
####################################################
build_county_models_to_file <- function(input_df,folder_name,input_test_field, input_predict_field){
### Builds a model for each county and exports each county to a file
###############################################
#### Create Folders if they don't exist
###############################################
### Models Folder
dir.create(file.path(workingDir, "models"), showWarnings = FALSE)
### Create Specific Sub Folder
dir.create(file.path(paste0(workingDir,"\\models"), folder_name), showWarnings = FALSE)
folder_path <- paste0(workingDir,"\\models\\",folder_name)
### Initialize filename vector. This will help up retrieve the folder names later
filename_v <- c()
### A few counties are too small to model, they need to be skipped
### This list tracks modeled counties
county_filenames <- c()
############################################
### Loop through input_df by county name
############################################
county_names <- sort(unique(input_df$county))
for (countyCounter in 1:length(county_names)) {
### init small counties, here so we dont accidentally overlook with incremental step throughs
if (countyCounter == 1){
too_small_to_calc_counties <- c()
}
### Get County Name for Loop
loop_county_name <- county_names[countyCounter]
print(paste0("[",countyCounter,"/",length(county_names),"] Processing:",loop_county_name))
### get data frame with just the County data
loop_county_df <- input_df[which(ca_covid_df$county==loop_county_name),]
#print(loop_county_df)
### Build offset columns for confirmed cases
loop_county_confirmed_df <- build_offset_columns(loop_county_df,input_test_field,2:30)
#print(tail(loop_county_confirmed_df))
### Build predictions for County: deaths ~ confirmed
loop_county_death_by_confirmed_df <- build_rolling_lm_offset(loop_county_confirmed_df,input_predict_field,15)
### IF the sum(mse) is less than 2, Ignore those counties and append to the too small to calc list
if (sum(loop_county_death_by_confirmed_df$mse) < 2) {
too_small_to_calc_counties <- append(too_small_to_calc_counties,loop_county_name)
next
}
#print(tail(loop_county_death_by_confirmed_df))
print(paste0("Sum MSE: ",sum(loop_county_death_by_confirmed_df$mse)))
####################################
#### Build summed data frame
####################################
#### First time through initialize the data frame
### lm_coefficient & offset_index need to be weighted by percentage of county population
### Get County Population
#loop_pop_weight <- ca_population_df[which(ca_population_df$county==loop_county_name),]$population
### There are at least two invalid counties - Out of County and Unassigned. Set Weight to 0
#if ( length(loop_pop_weight)  == 0)  {loop_pop_weight=0}
### Weight is a percentage of total population
#loop_pop_weight <- loop_pop_weight / ca_pop
#### These inlcude calculations for weighted counties
#### We should not be weighted. Will do that at the state levels
#output_df <- data.frame(
#  date =loop_county_death_by_confirmed_df$date,
#  predict_mse=loop_county_death_by_confirmed_df$mse,
#  predict_deaths=loop_county_death_by_confirmed_df$predicted_deaths,
#  predict_intercept =loop_county_death_by_confirmed_df$lm_intercept * loop_pop_weight,
#  predict_coefficient = (loop_county_death_by_confirmed_df$lm_coefficient * loop_pop_weight ),
#  predict_offset = (loop_county_death_by_confirmed_df$offset_index * loop_pop_weight)
#)
output_df <- data.frame(
date =loop_county_death_by_confirmed_df$date,
predict_mse=loop_county_death_by_confirmed_df$mse,
predict_deaths=loop_county_death_by_confirmed_df$predicted_deaths,
predict_intercept =loop_county_death_by_confirmed_df$lm_intercept,
predict_coefficient = loop_county_death_by_confirmed_df$lm_coefficient,
predict_offset = loop_county_death_by_confirmed_df$offset_index
)
### Write the data frame to disk
### Build Filename with full path
write_filename <- paste0(folder_path,"\\",loop_county_name,".dat")
print("full File Name: ")
print(write_filename)
saveRDS(output_df, write_filename)
### Append filename to the filelist for later summation
filename_v <- append(filename_v,write_filename)
### Only Counties that have good data are tracked
county_filenames <- append(county_filenames,loop_county_name)
}#//*** END Each County
#colnames(index_df) <- c("county","filenames")
index_filename <- paste0(folder_path,"\\1_index.dat")
#print("Index Filename")
#print(index_filename)
### Build an index data frame containing all the files for easier access
index_df <- data.frame(
county = county_filenames,
filenames = filename_v
)
#colnames(index_df) <- c("county","filenames")
saveRDS(index_df, index_filename)
}#//*** END build_county_models_to_file
ca_covid_confirm_predict_death_model_df <- build_statewide_model_from_counties(paste0(workingDir,"\\models\\ca_covid_confirm_~_deaths"))
ca_covid_confirm_predict_death_model_df
ca_combined_df
confirm_predict_death_model_df <- build_statewide_model_from_counties(paste0(workingDir,"\\models\\confirm_~_deaths"))
build_statewide_model_from_counties <- function(input_folder){
#######################################
### Get the Index File
### Because we make it easy!
#######################################
file_index <- readRDS(paste0(working_model_path,"\\1_index.dat"))
colnames(file_index) <- c("county","filenames")
for (county_filename_counter in 1:length(file_index$filenames)){
county_filename <- file_index$filenames[ county_filename_counter]
county_name <- file_index$county[ county_filename_counter]
loop_county_df <- readRDS(county_filename)
print("------------------------")
print(county_name)
print("------------------------")
print((loop_county_df))
if(county_filename_counter == 1){
### Initialize output variables
output_dates <- loop_county_df$date
#### Build a vector of 0 with length of the input_df
#### We start with 0 and sum each field
dataset_length <- nrow(loop_county_df)
for (x in 1:length(dataset_length)){
if (x == 1) { zero_vector <- c() }
zero_vector <- append(zero_vector,0)
}
output_mse <- zero_vector
output_deaths  <- zero_vector
output_intercept  <- zero_vector
output_coefficient  <- zero_vector
output_offset <- zero_vector
}#//*** END initialize output variables
#############################################################################
### Build output values
### Each value is a vector based on days. Add the vector to the output totals
### to get the Statewide numbers
#############################################################################
### Start with unweighted Values
output_mse <- output_mse + loop_county_df$predict_mse
output_deaths <- output_deaths + loop_county_df$predict_deaths
########################################################################################################
#### Build Weights based on population percentage
########################################################################################################
### Get County Population
loop_pop_weight <- ca_population_df[which(ca_population_df$county==county_name),]$population
### There are at least two invalid counties - Out of County and Unassigned. Set Weight to 0
if ( length(loop_pop_weight)  == 0)  {loop_pop_weight=0}
### Weight is a percentage of total population
loop_pop_weight <- loop_pop_weight / ca_pop
#print("Pop weight")
#print(loop_pop_weight)
########################################################################################################
#### Build Weighted values - these values are multiplied by their percentage of the population
########################################################################################################
if (is.na(loop_county_df$predict_offset)) {
print("DING")
break
}
output_intercept <- (output_intercept + (loop_county_df$predict_intercept * loop_pop_weight) )
offset_result <- output_offset + (loop_county_df$predict_offset * loop_pop_weight)
### Check for NAs for some reason These are occurring in low population counties
if (is.na(offset_result) == TRUE){
print(loop_county_df)
print("OFFSET NA!")
break
}
output_offset <- (output_offset + (loop_county_df$predict_offset * loop_pop_weight) )
output_coefficient <- (output_coefficient + (loop_county_df$predict_coefficient * loop_pop_weight) )
}#//*** END Each county filename
### Truncate the offset - might be useful to keep later
### output_offset <- round(output_offset,0)
return(data.frame(
predict_deaths      = output_deaths,
predict_offset      = output_offset,
predict_mse         = output_mse,
predict_intercept   = output_intercept,
predict_coefficient = output_coefficient
))
}#//END build_statewide_model_from_counties
confirm_predict_death_model_df <- build_statewide_model_from_counties(paste0(workingDir,"\\models\\confirm_~_deaths"))
build_statewide_model_from_counties <- function(input_folder){
#######################################
### Get the Index File
### Because we make it easy!
#######################################
file_index <- readRDS(paste0(working_model_path,"\\1_index.dat"))
colnames(file_index) <- c("county","filenames")
for (county_filename_counter in 1:length(file_index$filenames)){
county_filename <- file_index$filenames[ county_filename_counter]
county_name <- file_index$county[ county_filename_counter]
loop_county_df <- readRDS(county_filename)
print("------------------------")
print(county_name)
print("------------------------")
print((loop_county_df))
if(county_filename_counter == 1){
### Initialize output variables
output_dates <- loop_county_df$date
#### Build a vector of 0 with length of the input_df
#### We start with 0 and sum each field
dataset_length <- nrow(loop_county_df)
for (x in 1:length(dataset_length)){
if (x == 1) { zero_vector <- c() }
zero_vector <- append(zero_vector,0)
}
output_mse <- zero_vector
output_deaths  <- zero_vector
output_intercept  <- zero_vector
output_coefficient  <- zero_vector
output_offset <- zero_vector
}#//*** END initialize output variables
#############################################################################
### Build output values
### Each value is a vector based on days. Add the vector to the output totals
### to get the Statewide numbers
#############################################################################
### Start with unweighted Values
output_mse <- output_mse + loop_county_df$predict_mse
output_deaths <- output_deaths + loop_county_df$predict_deaths
########################################################################################################
#### Build Weights based on population percentage
########################################################################################################
### Get County Population
loop_pop_weight <- ca_population_df[which(ca_population_df$county==county_name),]$population
### There are at least two invalid counties - Out of County and Unassigned. Set Weight to 0
if ( length(loop_pop_weight)  == 0)  {loop_pop_weight=0}
### Weight is a percentage of total population
loop_pop_weight <- loop_pop_weight / ca_pop
#print("Pop weight")
#print(loop_pop_weight)
########################################################################################################
#### Build Weighted values - these values are multiplied by their percentage of the population
########################################################################################################
if (is.na(loop_county_df$predict_offset)) {
print("DING")
break
}
if (loop_county_df$predict_offset == "NA") {
print("DONG!")
return()
}
output_intercept <- (output_intercept + (loop_county_df$predict_intercept * loop_pop_weight) )
offset_result <- output_offset + (loop_county_df$predict_offset * loop_pop_weight)
### Check for NAs for some reason These are occurring in low population counties
if (is.na(offset_result) == TRUE){
print(loop_county_df)
print("OFFSET NA!")
break
}
output_offset <- (output_offset + (loop_county_df$predict_offset * loop_pop_weight) )
output_coefficient <- (output_coefficient + (loop_county_df$predict_coefficient * loop_pop_weight) )
}#//*** END Each county filename
### Truncate the offset - might be useful to keep later
### output_offset <- round(output_offset,0)
return(data.frame(
predict_deaths      = output_deaths,
predict_offset      = output_offset,
predict_mse         = output_mse,
predict_intercept   = output_intercept,
predict_coefficient = output_coefficient
))
}#//END build_statewide_model_from_counties
confirm_predict_death_model_df <- build_statewide_model_from_counties(paste0(workingDir,"\\models\\confirm_~_deaths"))
build_statewide_model_from_counties <- function(input_folder){
#######################################
### Get the Index File
### Because we make it easy!
#######################################
file_index <- readRDS(paste0(working_model_path,"\\1_index.dat"))
colnames(file_index) <- c("county","filenames")
for (county_filename_counter in 1:length(file_index$filenames)){
county_filename <- file_index$filenames[ county_filename_counter]
county_name <- file_index$county[ county_filename_counter]
loop_county_df <- readRDS(county_filename)
print("------------------------")
print(county_name)
print("------------------------")
print((loop_county_df))
if(county_filename_counter == 1){
### Initialize output variables
output_dates <- loop_county_df$date
#### Build a vector of 0 with length of the input_df
#### We start with 0 and sum each field
dataset_length <- nrow(loop_county_df)
for (x in 1:length(dataset_length)){
if (x == 1) { zero_vector <- c() }
zero_vector <- append(zero_vector,0)
}
output_mse <- zero_vector
output_deaths  <- zero_vector
output_intercept  <- zero_vector
output_coefficient  <- zero_vector
output_offset <- zero_vector
}#//*** END initialize output variables
#############################################################################
### Build output values
### Each value is a vector based on days. Add the vector to the output totals
### to get the Statewide numbers
#############################################################################
### Start with unweighted Values
output_mse <- output_mse + loop_county_df$predict_mse
output_deaths <- output_deaths + loop_county_df$predict_deaths
########################################################################################################
#### Build Weights based on population percentage
########################################################################################################
### Get County Population
loop_pop_weight <- ca_population_df[which(ca_population_df$county==county_name),]$population
### There are at least two invalid counties - Out of County and Unassigned. Set Weight to 0
if ( length(loop_pop_weight)  == 0)  {loop_pop_weight=0}
### Weight is a percentage of total population
loop_pop_weight <- loop_pop_weight / ca_pop
#print("Pop weight")
#print(loop_pop_weight)
########################################################################################################
#### Build Weighted values - these values are multiplied by their percentage of the population
########################################################################################################
if (is.na(loop_county_df$predict_offset)) {
print("DING")
return()
break
}
if (loop_county_df$predict_offset == "NA") {
print("DONG!")
return()
}
output_intercept <- (output_intercept + (loop_county_df$predict_intercept * loop_pop_weight) )
offset_result <- output_offset + (loop_county_df$predict_offset * loop_pop_weight)
### Check for NAs for some reason These are occurring in low population counties
if (is.na(offset_result) == TRUE){
print(loop_county_df)
print("OFFSET NA!")
break
}
output_offset <- (output_offset + (loop_county_df$predict_offset * loop_pop_weight) )
output_coefficient <- (output_coefficient + (loop_county_df$predict_coefficient * loop_pop_weight) )
}#//*** END Each county filename
### Truncate the offset - might be useful to keep later
### output_offset <- round(output_offset,0)
return(data.frame(
predict_deaths      = output_deaths,
predict_offset      = output_offset,
predict_mse         = output_mse,
predict_intercept   = output_intercept,
predict_coefficient = output_coefficient
))
}#//END build_statewide_model_from_counties
confirm_predict_death_model_df <- build_statewide_model_from_counties(paste0(workingDir,"\\models\\confirm_~_deaths"))
confirm_predict_death_model_df
build_statewide_model_from_counties <- function(input_folder){
#######################################
### Get the Index File
### Because we make it easy!
#######################################
file_index <- readRDS(paste0(working_model_path,"\\1_index.dat"))
colnames(file_index) <- c("county","filenames")
for (county_filename_counter in 1:length(file_index$filenames)){
county_filename <- file_index$filenames[ county_filename_counter]
county_name <- file_index$county[ county_filename_counter]
loop_county_df <- readRDS(county_filename)
print("------------------------")
print(county_name)
print("------------------------")
print((loop_county_df))
if(county_filename_counter == 1){
### Initialize output variables
output_dates <- loop_county_df$date
#### Build a vector of 0 with length of the input_df
#### We start with 0 and sum each field
dataset_length <- nrow(loop_county_df)
for (x in 1:length(dataset_length)){
if (x == 1) { zero_vector <- c() }
zero_vector <- append(zero_vector,0)
}
output_mse <- zero_vector
output_deaths  <- zero_vector
output_intercept  <- zero_vector
output_coefficient  <- zero_vector
output_offset <- zero_vector
}#//*** END initialize output variables
#############################################################################
### Build output values
### Each value is a vector based on days. Add the vector to the output totals
### to get the Statewide numbers
#############################################################################
### Start with unweighted Values
output_mse <- output_mse + loop_county_df$predict_mse
output_deaths <- output_deaths + loop_county_df$predict_deaths
########################################################################################################
#### Build Weights based on population percentage
########################################################################################################
### Get County Population
loop_pop_weight <- ca_population_df[which(ca_population_df$county==county_name),]$population
### There are at least two invalid counties - Out of County and Unassigned. Set Weight to 0
if ( length(loop_pop_weight)  == 0)  {loop_pop_weight=0}
### Weight is a percentage of total population
loop_pop_weight <- loop_pop_weight / ca_pop
#print("Pop weight")
#print(loop_pop_weight)
########################################################################################################
#### Build Weighted values - these values are multiplied by their percentage of the population
########################################################################################################
if (is.na(loop_county_df$predict_offset)) {
print("DING")
return()
break
}
print(loop_county_df$predict_offset)
print(length(loop_county_df$predict_offset))
output_intercept <- (output_intercept + (loop_county_df$predict_intercept * loop_pop_weight) )
offset_result <- output_offset + (loop_county_df$predict_offset * loop_pop_weight)
### Check for NAs for some reason These are occurring in low population counties
if (is.na(offset_result) == TRUE){
print(loop_county_df)
print("OFFSET NA!")
break
}
output_offset <- (output_offset + (loop_county_df$predict_offset * loop_pop_weight) )
output_coefficient <- (output_coefficient + (loop_county_df$predict_coefficient * loop_pop_weight) )
}#//*** END Each county filename
### Truncate the offset - might be useful to keep later
### output_offset <- round(output_offset,0)
return(data.frame(
predict_deaths      = output_deaths,
predict_offset      = output_offset,
predict_mse         = output_mse,
predict_intercept   = output_intercept,
predict_coefficient = output_coefficient
))
}#//END build_statewide_model_from_counties
confirm_predict_death_model_df <- build_statewide_model_from_counties(paste0(workingDir,"\\models\\confirm_~_deaths"))
confirm_predict_icu_model_df
