return(sum(this_df$daily_total_confirmed) )
},simplify="array")
daily_total_deaths <- sapply(date,function(x){
this_df <- (input_df [which(input_df$date == x),])
### Sum deaths for daily total
return(sum(this_df$daily_total_deaths) )
},simplify="array")
new_deaths <- sapply(date,function(x){
this_df <- (input_df [which(input_df$date == x),])
### Sum deaths for daily total
return(sum(this_df$new_deaths) )
},simplify="array")
new_confimed <- sapply(date,function(x){
this_df <- (input_df [which(input_df$date == x),])
### Sum deaths for daily total
return(sum(this_df$new_confirmed) )
},simplify="array")
return(data.frame(date,daily_total_confirmed,new_confimed,daily_total_deaths,new_deaths))
}#// END build statewide numbers
build_statewide_hospital_numbers <- function(input_df){
#### Sum the numbers across the state to build a big picture estimate
### Build unique dates
date <- unique(input_df$date)
### build statewide confirmed numbers
hospitalized_covid_patients <- sapply(date,function(x){
### Build data frame for each date
this_df <- (input_df [which(input_df$date == x),])
### Sum confirmed for daily total
return(sum(this_df$hospitalized_covid_patients) )
},simplify="array")
all_hospital_beds <- sapply(date,function(x){
this_df <- (input_df [which(input_df$date == x),])
### Sum deaths for daily total
return(sum(this_df$all_hospital_beds) )
},simplify="array")
icu_available_beds <- sapply(date,function(x){
this_df <- (input_df [which(input_df$date == x),])
### Sum deaths for daily total
return(sum(this_df$icu_available_beds) )
},simplify="array")
icu_combined <- sapply(date,function(x){
this_df <- (input_df [which(input_df$date == x),])
### Sum deaths for daily total
return(sum(this_df$icu_combined) )
},simplify="array")
hospital_capacity <- sapply(date,function(x){
this_df <- (input_df [which(input_df$date == x),])
### Sum deaths for daily total
return(sum(this_df$hospital_capacity) )
},simplify="array")
icu_capacity <- sapply(date,function(x){
this_df <- (input_df [which(input_df$date == x),])
### Sum deaths for daily total
return(sum(this_df$icu_capacity) )
},simplify="array")
### Stitch in actual deaths - 12 days
return(data.frame(date=date,
daily_total_deaths = daily_covid_df$daily_total_deaths[12:nrow(daily_covid_df)],
hospitalized_covid_patients=hospitalized_covid_patients,
all_hospital_beds=all_hospital_beds,
icu_available_beds=icu_available_beds,
icu_combined=icu_combined,
hospital_capacity=hospital_capacity,
icu_capacity=icu_capacity
))
}#// END build statewide numbers
############################
### Population Functions ###
###########################################
### Get the county population per 100k. ###
###############################################################################################
### Useful for get counties with large population disparities on a similar per capita scale ###
###############################################################################################
county_pop_100k <- function(input_county){
### get the county population divided by 100,000 thousand.
return(ca_population_df$pop_100k[which(ca_population_df$county==input_county)] )
}#//*** END county_pop_100k
#### Statewide Preview Model
correlation_model_statewide_by_summed_county <- function(input_df,input_test_field, input_predict_field){
### Build a statewide model of an attribute by modeling each County and summing the results.
### This is a relatively quick model, good for preliminary investigation.
### The Best model is a 15 day model using linear models. Correlation fails below 30. But it is fast.
###
county_names <- sort(unique(input_df$county))
#### Loop through each county Name and Build an offset
for (countyCounter in 1:length(county_names)) {
### init small counties, here so we dont accidentally overlook with incremental step throughs
if (countyCounter == 1){
too_small_to_calc_counties <- c()
}
### Get County Name for Loop
loop_county_name <- county_names[countyCounter]
print(paste0("BEGIN:",loop_county_name))
### get data frame with just the County data
loop_county_df <- input_df[which(input_df$county==loop_county_name),]
#print(tail(loop_county_df))
### Build offset columns for confirmed cases
loop_county_offset_df <- build_offset_columns(loop_county_df,input_test_field,2:30)
#print(tail(loop_county_offset_df))
### Build predictions for County: deaths ~ confirmed
loop_county_cor_df <- build_rolling_cor_offset(loop_county_offset_df,input_predict_field,30)
#print(tail(loop_county_cor_df))
### IF the sum(mse) is less than 2, Ignore those counties and append to the too small to calc list
if (sum(loop_county_cor_df$mse) < 2) {
too_small_to_calc_counties <- append(too_small_to_calc_counties,loop_county_name)
next
}
#print(tail(loop_county_cor_df))
print(paste0("Sum MSE: ",sum(loop_county_cor_df$mse)))
####################################
#### Build summed data frame
####################################
#### First time through initialize the data frame
if (countyCounter == 1) {
output_df <- data.frame(
date=loop_county_cor_df$date,
confirm_mse=loop_county_cor_df$mse,
confirm_deaths=loop_county_cor_df$predicted_deaths
)
next
}#//*** END initialize data frame
### Add in County data to cor_model_statewide_by_county_30_df
print(loop_county_name)
### Sum the county data and update the statewide output_df
for (updateCounter in 1:nrow(loop_county_cor_df)){
loop_master_row <- output_df[updateCounter,]
loop_county_cor_row <- loop_county_cor_df[updateCounter,]
#print(sum(loop_county_cor_row$mse))
#print(sum(loop_county_cor_row$predicted_deaths))
#### Sum Confirmed MSE
loop_master_row$confirm_mse <- sum(loop_master_row$confirm_mse + loop_county_cor_row$mse)
#### Sum Confirmed predicted deaths
loop_master_row$confirm_deaths <- sum(loop_master_row$confirm_deaths + loop_county_cor_row$predicted_deaths)
output_df[updateCounter,] <- loop_master_row
#print(loop_master_row)
}#//*** END Update State Model
#print(tail(output_df))
}###END each county same
return(output_df)
}#// END Build a state wide model by summed County using 30 correlation Model
####################################################
#### Expensive County Modeling
#### Models each County and writes to a file
####################################################
build_county_models_to_file <- function(input_df,folder_name,input_test_field, input_predict_field,rolling_days){
### Builds a model for each county and exports each county to a file
###############################################
#### Create Folders if they don't exist
###############################################
### Models Folder
dir.create(file.path(workingDir, "models"), showWarnings = FALSE)
### Create Specific Sub Folder
dir.create(file.path(paste0(workingDir,"\\models"), folder_name), showWarnings = FALSE)
folder_path <- paste0(workingDir,"\\models\\",folder_name)
### Initialize filename vector. This will help up retrieve the folder names later
filename_v <- c()
### A few counties are too small to model, they need to be skipped
### This list tracks modeled counties
county_filenames <- c()
############################################
### Loop through input_df by county name
############################################
county_names <- sort(unique(input_df$county))
for (countyCounter in 1:length(county_names)) {
### init small counties, here so we dont accidentally overlook with incremental step throughs
if (countyCounter == 1){
too_small_to_calc_counties <- c()
}
### Get County Name for Loop
loop_county_name <- county_names[countyCounter]
print(paste0("[",countyCounter,"/",length(county_names),"] Processing:",loop_county_name))
### get data frame with just the County data
loop_county_df <- input_df[which(input_df$county==loop_county_name),]
#print(loop_county_df)
### Build the dependent variable
eval(parse(text=paste0("dependent_variable <- input_df[which(input_df$county==loop_county_name),]$",input_test_field)))
### Build offset columns for confirmed cases
loop_county_confirmed_df <- build_offset_columns(loop_county_df,input_test_field,2:30)
#print(tail(loop_county_confirmed_df))
### Build predictions for County: deaths ~ confirmed
loop_county_death_by_confirmed_df <- build_rolling_lm_offset(loop_county_confirmed_df,input_predict_field,rolling_days)
### IF the sum(mse) is less than 2, Ignore those counties and append to the too small to calc list
if (sum(loop_county_death_by_confirmed_df$mse) < 2) {
too_small_to_calc_counties <- append(too_small_to_calc_counties,loop_county_name)
next
}
#print(tail(loop_county_death_by_confirmed_df))
print(paste0("Sum MSE: ",sum(loop_county_death_by_confirmed_df$mse)))
####################################
#### Build summed data frame
####################################
#### First time through initialize the data frame
### lm_coefficient & offset_index need to be weighted by percentage of county population
### Get County Population
#loop_pop_weight <- ca_population_df[which(ca_population_df$county==loop_county_name),]$population
### There are at least two invalid counties - Out of County and Unassigned. Set Weight to 0
#if ( length(loop_pop_weight)  == 0)  {loop_pop_weight=0}
### Weight is a percentage of total population
#loop_pop_weight <- loop_pop_weight / ca_pop
#### These inlcude calculations for weighted counties
#### We should not be weighted. Will do that at the state levels
#output_df <- data.frame(
#  date =loop_county_death_by_confirmed_df$date,
#  predict_mse=loop_county_death_by_confirmed_df$mse,
#  predict_deaths=loop_county_death_by_confirmed_df$predicted_deaths,
#  predict_intercept =loop_county_death_by_confirmed_df$lm_intercept * loop_pop_weight,
#  predict_coefficient = (loop_county_death_by_confirmed_df$lm_coefficient * loop_pop_weight ),
#  predict_offset = (loop_county_death_by_confirmed_df$offset_index * loop_pop_weight)
#)
output_df <- data.frame(
date =loop_county_death_by_confirmed_df$date,
dependent=dependent_variable,
predict_mse=loop_county_death_by_confirmed_df$mse,
prediction=loop_county_death_by_confirmed_df$predicted_deaths,
predict_intercept =loop_county_death_by_confirmed_df$lm_intercept,
predict_coefficient = loop_county_death_by_confirmed_df$lm_coefficient,
predict_offset = loop_county_death_by_confirmed_df$offset_index
)
### Write the data frame to disk
### Build Filename with full path
write_filename <- paste0(folder_path,"\\",loop_county_name,".dat")
print("full File Name: ")
print(write_filename)
saveRDS(output_df, write_filename)
### Append filename to the filelist for later summation
filename_v <- append(filename_v,write_filename)
### Only Counties that have good data are tracked
county_filenames <- append(county_filenames,loop_county_name)
}#//*** END Each County
#colnames(index_df) <- c("county","filenames")
index_filename <- paste0(folder_path,"\\1_index.dat")
#print("Index Filename")
#print(index_filename)
### Build an index data frame containing all the files for easier access
index_df <- data.frame(
county = county_filenames,
filenames = filename_v
)
#colnames(index_df) <- c("county","filenames")
saveRDS(index_df, index_filename)
}#//*** END build_county_models_to_file
#build_county_models_to_file(ca_covid_df,"confirm_~_deaths","daily_total_confirmed","daily_total_deaths")
##############################################################
#### Build statewide models from expensive county models ####
#####################################################################################
#### Reads county models from a file and returns a data frame of aggregated info ####
#####################################################################################
#confirm_predict_death_model_df <- build_statewide_model_from_counties(paste0(workingDir,"\\models\\confirm_~_deaths"))
print("DONE: Build Functions")
} #//***END Code Chunk Build Functions!
###################################################################################
### Assign the working Directory. I work on 3x PCs, hence three directory choices
###################################################################################
#workingDir <- "C:\\DSC\\covid"
#workingDir <- "C:\\Users\\newcomb\\DSCProjects\\DSC\\covid"
workingDir <- "C:\\Users\\stonk013\\Documents\\GitHub\\DSC\\covid"
setwd(workingDir)
{ #*//BEGIN - Code Chunk #1 - Initialization
print("PROCESSING: Code Chunk #1")
########################################################
### Build Covid Confirmed and Deaths                 ###
### Source Data is by county and date.               ###
########################################################
ca_covid_df <- process_CA_covid_cases_data(read.csv("CA_covid_Cases.csv"))
##############################
### Build Hospital Dataset ###
##############################
### Source Data is by county and date.
ca_hospital_df <- process_CA_hospital_data(read.csv("CA_covid_Hospitalization.csv"))
#############################
### Build Testing Dataset ###
###########################################
### import Testing info directly.       ###
### Cleaning: Convert date to as.Date() ###
### Data is at state level              ###
###########################################
ca_testing_df <- read.csv("CA_testing.csv")
ca_testing_df$date <- as.Date(ca_testing_df$date,"%Y-%m-%d")
### California Demographics - May use later
#ca_demo_df <- read.csv("Final_CA_Race_Demographic.csv")
####################################################################
#### Build Population Risk factors
#### Mostly this is for the population data
#### Might as well keep it and clean it
####################################################################
ca_risk_factors_df <- read.csv("final_CA_county_population.csv")
ca_risk_factors_df <- removeCols(ca_risk_factors_df,c('X'))
#### Build County Population numbers
ca_population_df <- data.frame(county = ca_risk_factors_df$county,
population = ca_risk_factors_df$population,
pop_100k = round(ca_risk_factors_df$population/100000,2)
)
########################################################
### Statewide population
########################################################
ca_pop <- sum(ca_population_df$population)
### Statewide population, per 100,000
ca_pop_100k <- round(ca_pop / 100000,2)
############################################################
### build statewide Numbers - daily_covid_df
############################################################
daily_covid_df <- build_statewide_confirmed_numbers(ca_covid_df)
####################################################
### Process ca_covid_df again
### Rename columns and remove new count numbers
### Should be handled in initial processing,
### But that creates a significant refactor
### Will bolt on and move on
####################################################
#ca_covid_df <- removeCols(ca_covid_df,c("newcountconfirmed","newcountdeaths"))
#colnames(ca_covid_df) <- c("county","daily_total_confirmed","daily_total_deaths","date")
############################################
#### Build statewide Hospital numbers
############################################
### Hospital has least least rows start there
daily_hospital_df <- build_statewide_hospital_numbers(ca_hospital_df)
daily_hospital_df
### Remove bed count for simiplication. May use this later
ca_hospital_df <- removeCols(ca_hospital_df,c("all_hospital_beds","icu_available_beds"))
daily_hospital_df <- removeCols(daily_hospital_df,c("all_hospital_beds","icu_available_beds","hospital_capacity","icu_capacity"))
daily_hospital_df
### Add Deaths to ca_hospital_df
### Combine ca_covid and ca_hospital
ca_combined_df <- merge(ca_covid_df,ca_hospital_df)
ca_combined_df
### Add Statewide deaths to testing for offset building
ca_testing_df <- data.frame(date=ca_testing_df$date,daily_total_deaths=daily_covid_df$daily_total_deaths,tested=ca_testing_df$tested)
tail(ca_combined_df)
daily_hospital_df
daily_covid_df
daily_combined_df <- merge(daily_covid_df,daily_hospital_df)
#colnames(ca_covid_df)
#colnames(ca_combined_df) <- c()
############################################################
### build State confirmed offset columns -
### These are the columns to build days back offsets.
############################################################
############################################################
### Build the offsets data frame.
############################################################
offset_daily_df <- build_offset_columns(daily_combined_df,"daily_total_confirmed",2:30)
offset_testing_df <- build_offset_columns(ca_testing_df,"tested",2:30)
#offset_hospitalization <-build_offset_columns(daily_hospital_df,"daily_total_confirmed",2:30)
#offset_daily_df
print("END: Code Chunk #1")
}#*//END - Code Chunk #1 - Initialization
build_county_models_to_file(ca_combined_df,"confirm_~_deaths_30","daily_total_confirmed","daily_total_deaths",30)
confirm_predict_death_30_model_df <- build_statewide_model_from_counties(paste0(workingDir,"confirm_~_deaths_30"))
confirm_predict_death_30_model_df <- build_statewide_model_from_counties(paste0(workingDir,"\\models\\confirm_~_deaths_30"))
build_statewide_model_from_counties <- function(input_folder){
#######################################
### Get the Index File
### Because we make it easy!
#######################################
file_index <- readRDS(paste0(input_folder,"\\1_index.dat"))
colnames(file_index) <- c("county","filenames")
total_pop_weight <- 0
############################################################
#### Build filenames from the county names in file_index
#### Turns out the folder paths only on the machine that
#### did the modeling....Ooops.
############################################################
filenames <- paste0(input_folder,"\\",file_index$county,".dat")
for (county_filename_counter in 1:length(filenames)){
county_filename <- filenames[ county_filename_counter]
county_name <- file_index$county[ county_filename_counter]
loop_county_df <- readRDS(county_filename)
#######################################################
### We shouldnt have NAs in our models but we do.
### These should be zeros in the model generation
### But that is a huge pain to fix.
#######################################################
### Bolt on and move on
#######################################################
loop_county_df[is.na(loop_county_df)] = 0
print("------------------------")
print(county_name)
print("------------------------")
print(tail(loop_county_df))
if(county_filename_counter == 1){
### Initialize output variables
output_dates <- loop_county_df$date
#### Build a vector of 0 with length of the input_df
#### We start with 0 and sum each field
dataset_length <- nrow(loop_county_df)
for (x in 1:length(dataset_length)){
if (x == 1) { zero_vector <- c() }
zero_vector <- append(zero_vector,0)
}
output_mse <- zero_vector
output_dependent <- zero_vector
output_deaths  <- zero_vector
output_intercept  <- zero_vector
output_coefficient  <- zero_vector
output_offset <- zero_vector
}#//*** END initialize output variables
#############################################################################
### Build output values
### Each value is a vector based on days. Add the vector to the output totals
### to get the Statewide numbers
#############################################################################
### Start with unweighted Values
output_mse <- output_mse + loop_county_df$predict_mse
output_deaths <- output_deaths + loop_county_df$prediction
output_dependent <- output_dependent + loop_county_df$dependent
########################################################################################################
#### Build Weights based on population percentage
########################################################################################################
### Get County Population
#loop_pop_weight <- ca_population_df[which(ca_population_df$county==county_name),]$population
### There are at least two invalid counties - Out of County and Unassigned. Set Weight to 0
#if ( length(loop_pop_weight)  == 0)  {loop_pop_weight=0}
### Weight is a percentage of total population
#loop_pop_weight <- loop_pop_weight / ca_pop
#print("Pop weight")
#print(loop_pop_weight)
########################################################################################################
#### Build Weighted values - these values are multiplied by their percentage of the population
########################################################################################################
#############################################################################
### Replace NA with 0. The Models should not be generating NA
### But it's likely from low population counties. Let's go with it ATM.
#############################################################################
#loop_county_df$predict_offset[is.na(loop_county_df$predict_offset)] <- 0
#loop_county_df$predict_intercept[is.na(loop_county_df$predict_intercept)] <- 0
#loop_county_df$predict_coefficient[is.na(loop_county_df$predict_coefficient)] <- 0
#output_intercept <- (output_intercept + (loop_county_df$predict_intercept * loop_pop_weight) )
#loop_county_df$predict_offset <- as.double(loop_county_df$predict_offset)
#output_offset <-    (output_offset + (loop_county_df$predict_offset * loop_pop_weight) )
#loop_county_df$predict_coefficient <- as.double(loop_county_df$predict_coefficient)
#output_coefficient <- (output_coefficient + (loop_county_df$predict_coefficient * loop_pop_weight) )
}#//*** END Each county filename
total_weight <- 0
total_predict <- zero_vector
### Build weighted values
### Need to go back through again
for (county_filename_counter in 1:length(filenames)){
county_filename <- filenames[ county_filename_counter]
county_name <- file_index$county[ county_filename_counter]
loop_county_df <- readRDS(county_filename)
#######################################################
### We shouldnt have NAs in our models but we do.
### These should be zeros in the model generation
### But that is a huge pain to fix.
#######################################################
### Bolt on and move on
#######################################################
loop_county_df[is.na(loop_county_df)] = 0
#print("------------------------")
#print(county_name)
#print("------------------------")
#print(tail(loop_county_df))
#print(county_name)
########################################################################################################
#### Build Weights based on percentage of total deathss
########################################################################################################
### Get County Population
#loop_pop_weight <- ca_population_df[which(ca_population_df$county==county_name),]$population
### There are at least two invalid counties - Out of County and Unassigned. Set Weight to 0
#if ( length(loop_pop_weight)  == 0)  {loop_pop_weight=0}
### Weight is a percentage of total population
#loop_pop_weight <- loop_pop_weight / ca_pop
#print("Pop weight")
#print(loop_pop_weight)
########################################################################################################
#### Build Weighted values - these values are multiplied by their percentage of the population
########################################################################################################
#############################################################################
### Replace NA with 0. The Models should not be generating NA
### But it's likely from low population counties. Let's go with it ATM.
#############################################################################
#loop_county_df$predict_offset[is.na(loop_county_df$predict_offset)] <- 0
#loop_county_df$predict_intercept[is.na(loop_county_df$predict_intercept)] <- 0
#loop_county_df$predict_coefficient[i/2s.na(loop_county_df$predict_coefficient)] <- 0
loop_death_weight <- loop_county_df$prediction/output_deaths
loop_death_weight[is.na(loop_death_weight)] = 0
#print(loop_death_weight)
total_weight <- total_weight +  loop_death_weight
output_intercept <- (output_intercept + (loop_county_df$predict_intercept * loop_death_weight) )
output_offset <-    (output_offset + (loop_county_df$predict_offset * loop_death_weight) )
temp_co <- (loop_county_df$predict_coefficient * loop_death_weight)
output_coefficient <- (output_coefficient +  temp_co)
total_predict <- ( total_predict + (loop_county_df$prediction * loop_death_weight) )
#print(loop_county_df$predict_coefficient)
#print(loop_county_df$predict_coefficient * loop_death_weight)
#print(loop_county_df$prediction * loop_death_weight)
#print(tail(
#  data.frame(
#    total=output_deaths,
#    county=loop_county_df$prediction,
#    percent=loop_county_df$prediction/output_deaths,
#    coef=loop_county_df$predict_coefficient,
#    percent_coef=loop_county_df$predict_coefficient*(loop_county_df$prediction/output_deaths)
#    )))
}#//*** END Each county filename
return(data.frame(
prediction          = output_deaths,
dependent           = output_dependent,
predict_offset      = output_offset,
predict_mse         = output_mse
#predict_intercept   = output_intercept,
#predict_coefficient = output_coefficient
))
}#//END build_statewide_model_from_counties
confirm_predict_death_30_model_df <- build_statewide_model_from_counties(paste0(workingDir,"\\models\\confirm_~_deaths_30"))
sum(confirm_predict_death_30_model_df$predict_mse)
sum(confirm_predict_death_model_df$predict_mse)
### Confirmed cases predicting outcomes
confirm_predict_death_model_df <- build_statewide_model_from_counties(paste0(workingDir,"\\models\\confirm_~_deaths"))
sum(confirm_predict_death_model_df$predict_mse)
sum(confirm_predict_death_30_model_df$predict_mse)
sum(confirm_predict_death_model_df$predict_mse)
